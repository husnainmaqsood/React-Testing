regression is the state in which our application goes to the previous state instead of current state.

we can say our application succeeded when our application passes all unit tests.

what if tests didn't exits: then if we change something in our application the we have to check each and every page manually.
without tests there is no way to measure the correctness of the code.

unit test tests single function or unit. like if a number is prime or not.

to do this, we need some kind of test runner like jest / mocha.

component tests single component(functionality) like widget, dropdown etc. we need more sophisticated tools like jest/ enzyme.

snapshot test: also tests single component but it avoids us from regression. we'll need jest for this.

end to end test: tests interaction between multiple components.



 in component tests, we consider whole component as a unit.
component tests also test kind of functionality. they are highly sensitive to the small changes.

snapshot tests are subtype of component test. they are automatically generated by jest.veryfies if the output is same now as when we ran the test before. also sensitive to small changes.

tests which jest is not supposed to do. -> performance tests, coverage tests(tests for the tests)


end to end tests measures functionality of the whole application. different in nature and more difficult to write. they ensure that application works.

jest is a javascript library
it is a test runner
made by members including react team

main testing tools: jest, enzyme(used for testing react application, works with jest), jasmine/mocha

jasmine/mocha: very similar test runners, these organizes tests into describe and it blocks.
all assertions inside tests are verified.

jest also uses describe and it block. whenever test is run via command line, all assertions inside tests are verified.
doesn't inlcude mocking or snapshots.

jest:
  build on the top of jasmine and mocha(means it has all those features which they have).
it has a lot more features.

it has snapshot testing, mocking and many other features.
it also have a superior assertion library(CLI: Command Line Interface)
jest works for with react and it can also work without react.


enzyme: 
not a test runner like jest. doesn't tell whether a test is passed or not.but provides tools to test react apps specifically.
main purpose of enzyme: takes a component and make dom components out of it. like react test renderer.
enzyme is very useful but not for every project.

jest have two tools, jest itself and jest cli
jest is a test runner(if test is passed or not)
jest cli is used to run jest(configurations are in this).

jest is recommended to test the react applications.


pitfalls of jest: 
tests are not written, no integration with version control, jest is not integrated into devs' workflow, devs skip tests instead of fixing them, no integration with deployment/ ci , tests do not  protect against critical errors.


this types of folder name __test__/*.js is considered as a test folder and all files in this folder will be considered as test files.
* means anything

or

*.spec.js or *.test.js
these files will also be considered as test files.


describe and it
OR
suite and test

IT(TEST): is a method in which we pass a function, and that function is executed as block of tests by the test runner.

describe's first argument is the name of component that we are testing, second argument is a function(mostly arrow with no arguments)

we make assertions in it block.

jest --watch // takes us to the watch mode
if it doesn't works then use jest --watchAll

in watch mode, when we save the testfile then it automatically runs and gives us the results in the command line.

BeforeEach runs a block of code before each test.(useful for setting up databases, mock instances etc).
BeforeAll runs code just once, before the first test

AfterEach and before all are opposite to BeforeEach and BeforeAll.

They runs after test(or after the last test)(useful for closing open connection, terminating sub-processes)

"it" contains our tests

beforeEach and afterEach are for every test
but beforeAll and afterAlll are for all the tests

skipping or isolating test is used when we want to ignore a test to be run.(because it is creating issues).

method: mark a test as "skip" to ignore it and note the change in suite of tests

mark the test "only" to isolate
a dot(.) is put after it and required function is used. (skip or only)

using skip or only, jest doesn't fail the test. it passes all the tests even if they are giving incorrect outputs

one must do Asynchronous testing all the time while making real world application.
it is like normal tests. contains assertions(it block is called assertion)
doesn't complete instantaneously, can take varying amount of time.

how to notify jest:
invoke done() that is passed to the test
or
return a promise from a test
or
pass an async function to describe(best one)

we don't wrap it in the describe block instead we use should.

watch test is important


mocking reduces dependencies required by tests, prevent side effects, build custom mocks to facilitate desired testing procedures.

what is mocking? 
ans: mock is a convincing duplicate of an object with no internal working.
it can be created automatically or manually.
has the same API as original but no side effects.


mock functions are also known as spies.
don't create any side effects.
counts function calls.
records what arguments are passed when called.
can be loaded with return values
return value must approximate the original one.


process:
approximately names npm mocks are loaded automatically,
mocks must reside in a __mock__ folder next to mocked module(a module which we want to mock)
npm modules and local modules can both be mocked.

simple modules can be mocked automatically but complex modules require manual mocking.

snapshot is a json file, based on record of a component's output.

how snapshot testing works:
first import renderer from 'react-test-renderer'
we use renderer.create mathod to create a tree
tree is a html representation of the output of the component
once we have this tree, we run assertions to match snapshot.

first time we run snapshot, nothing is being tested

the snapshot testing process:

anywhere we use jsx we need to import react

tree is the json representation of the component.

renderer returns the generated html

snapshot is the state of our application at a particular time
we can update snapshot by putting -u after writing required test in the command line

describe blocks are optional. but it is good convention to surround it blocks with describe blocks.

mapStateToProps is a simple function that takes an object and returns another object.

matcher is also known as assertion
represents a claim that a value will be equal or not to something

toEqual is linent( can be ok with different obj with same values)
toBe is strict(if same object then ok otherwise not ok)

toContain also works like toBe


no assertions are equal to all assertions passed

in a test file there should be one test or it block to execute it.

we watch tests by entering in the watch mode.

jest is smart enough to know which files changed and from where in the snapshots.

jest --watch or jest --watchAll first runs all the tests and then give user the menu about the results of tests.

afterEach runs after every it statement
afterAll runs after the last it statement

skipping test and isolating test have same effects.(skip the test)

one must do asynchronous testing when building a real world application.
jest does it very well.
it is like normal tests, it has assertions
can take long time or short time.
in some way we have to notify jest that asynchronous test is completed.
3 methods of defining asynchronous tests.
i-invoke done() callback that is passed to the test and then invoke it when specific amount of time has passed.(maximum callback time is 5 seconds, if we invoke done in a time greater than 5 seconds then it will give us an error).
ii- any test returning a promise is asynchronous test, we can do this also. and won't be completed until the promise it resolved.
iii-the coolest method: pass an async function to it block and handle asyncinity using await function.(in this type, delay is shortened by the redux saga).

delay comes with redux saga.

in async await we have to give a promise after await. and until the promise is not resolved the code doesn't run further.

why mocking ? mocking reduces number of dependencies required by tests.

apperancewise mock is same as the original thing but internal functionality is missing in the mock.
mock is hollow.
mock is a convincing duplicate with no internal working.
can be created automatically or manually.

mocking process:
scan the object, make a new object give it methods with same names as in original one.(these methods are called spies in the mocked object).

in mocking if any method returned a promise, then is  should return a promise in the mock.

mock functions are also known as spies. they don't have side effects. they count functions calls.

mocks must be placed in __mocks__ folder 
and this folder must be placed in the same folder in which the module exists.

in snapshot testing
first we import renderer
then we also import the component

in the it block, we create a tree using renderer.create(pass props to the component)
then pass this tree to expect but parsed to json
expect(tree.toJSON()).toMatchSnapshot();

usually making call to APIs and change the state, is called side effects.

shallowRender rendres only a single component, it stays at one level down only. doesn't go deep.

in enzyme we just call find and pass a css selector and we get what we want.

behind the scenes enzyme is calling react test utils.

there are two ways to render a react component for testing with enzyme.
i- shallow: renders single component
ii- mount: renders component with children.

with shallow:
* No DOM is created
* no child components are rendered

with mount:
* DOM is created in memory via JSDOM (normal html, like Link is considered as "a"(anchor tag))
* Child components are rendered.


in react testing library, we call render instead of shallow.

using testing library, we don't call expect. it itself returns some methods via render.

for finding label, we destructure render's return call by getByText.

react testing library there is no shallow rendering. Components are always mounted.

we can also destructure debug function like getText in react testing library.
then we need to call this function like.
debug();
it will show us the output of the component in the console.